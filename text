package com.barclays.bpas.kafka;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

@Log4j2
@Component
@RequiredArgsConstructor
public class BpasKafkaProducer {

    private final BpasKafkaMessageProducer bpasKafkaMessageProducer;
    private final BpasDataAccess bpasDataAccess;

    private final BlockingQueue<KafkaMessage> messageQueue = new LinkedBlockingQueue<>();
    private volatile boolean running = true;

    @Value("${bpas.warehouse.topic}")
    private String warehouseTopic;

    private static final int BATCH_SIZE = 1000;
    private static final int POLL_TIMEOUT_MS = 500; // Max wait for queue poll

    @PostConstruct
    public void startProducerThread() {
        Thread.startVirtualThread(this::drainQueue);
        log.info("‚úÖ Kafka producer virtual thread started.");
    }

    @PreDestroy
    public void shutdown() {
        log.info("üîª Initiating shutdown of Kafka producer...");
        running = false;
    }

    private void drainQueue() {
        log.info("üîÑ Kafka queue draining thread started.");

        List<KafkaMessage> batch = new ArrayList<>(BATCH_SIZE);

        while (running || !messageQueue.isEmpty()) {
            try {
                KafkaMessage message = messageQueue.poll(POLL_TIMEOUT_MS, TimeUnit.MILLISECONDS);
                if (message != null) {
                    batch.add(message);
                }

                // Either batch is full or we're shutting down
                if (batch.size() >= BATCH_SIZE || (!running && !batch.isEmpty())) {
                    processBatch(batch);
                    batch.clear();
                }

            } catch (InterruptedException ie) {
                log.warn("‚ö†Ô∏è Producer thread interrupted: {}", ie.getMessage(), ie);
                Thread.currentThread().interrupt();
                break;
            } catch (Exception ex) {
                log.error("‚ùå Unexpected error in drainQueue: {}", ex.getMessage(), ex);
            }
        }

        // Final flush
        if (!batch.isEmpty()) {
            try {
                processBatch(batch);
                log.info("‚úÖ Final batch flushed on shutdown. Size: {}", batch.size());
            } catch (Exception ex) {
                log.error("‚ùå Failed to flush final batch: {}", ex.getMessage(), ex);
            }
        }

        log.info("‚úÖ Kafka producer thread exited cleanly.");
    }

    private void processBatch(List<KafkaMessage> batch) {
        try {
            // Example: store in DB or audit log (optional)
            bpasDataAccess.storeKafkaMessageBatch(batch);
            log.info("‚úÖ Stored batch of {} messages", batch.size());

            // Send to Kafka
            for (KafkaMessage msg : batch) {
                bpasKafkaMessageProducer.sendMessage(msg);
            }

        } catch (Exception ex) {
            log.error("‚ùå Error processing batch of size {}: {}", batch.size(), ex.getMessage(), ex);
            // Optionally re-enqueue for retry if needed:
            // batch.forEach(messageQueue::offer);
        }
    }

    public void receiveMessage(KafkaMessage message) {
        boolean accepted = messageQueue.offer(message);
        if (!accepted) {
            log.error("‚ùå Failed to enqueue message. Queue might be full (which shouldn't happen for unbounded queue)");
        } else {
            int size = messageQueue.size();
            if (size % 1000 == 0) {
                log.info("üìä Queue size at {} messages", size);
            }
        }
    }
}